# 小遥搜索 XiaoyaoSearch 技术方案

## 1. 技术选型

### 前端技术栈
- **框架**: Electron + electron-vue + Vue 3 + TypeScript
  - Electron提供跨平台桌面应用支持(Windows/macOS/Linux)
  - electron-vue简化Vue与Electron的集成开发
  - Vue 3 + Composition API提供现代化前端开发体验
  - Node.js 21+支持最新的JavaScript特性
- **UI框架**: Ant Design Vue
  - 企业级UI组件库，开箱即用
  - 完善的中文本地化支持
  - 符合PRD设计要求的组件体系
- **状态管理**: Pinia
  - Vue 3官方推荐的状态管理工具
  - 简洁的API设计，支持TypeScript
  - 良好的开发工具和调试支持
- **HTTP客户端**: Axios
  - 成熟的HTTP请求库
  - 支持请求/响应拦截
  - 与FastAPI后端通信

### 后端技术栈
- **语言**: Python 3.10
- **框架**: FastAPI + Uvicorn
  - FastAPI提供现代化API开发框架
  - Uvicorn提供ASGI服务器，支持WebSocket
- **异步处理**: asyncio + pydantic
  - 高性能异步I/O处理
  - Pydantic提供数据验证和序列化

### AI模型集成
- **文本嵌入**: BGE-M3
  - 中文优化文本嵌入模型，768维向量
  - 支持8192 tokens上下文长度
- **语音识别**: fasterWhisper + 阿里云语音识别API
  - fasterWhisper提供本地语音识别(30秒内2-3秒响应)
  - 阿里云API提供云端识别备选方案
- **视觉理解**: CN-CLIP + 阿里云视觉API
  - CN-CLIP提供中文图像-文本理解，本地部署
  - 阿里云API提供云端视觉理解备选
- **大语言模型**: Ollama + 阿里云大语言API
  - Ollama提供本地LLM服务(Qwen、ChatGLM、Baichuan等)
  - 阿里云API提供云端LLM备选

### 搜索引擎
- **向量搜索**: Faiss
  - Facebook AI Similarity Search，高效的向量相似度搜索
  - 支持IVF索引，提供快速向量检索
- **全文搜索**: Whoosh
  - Python全文搜索库，支持中文分词
  - 提供丰富的搜索查询语法
- **混合搜索**: Faiss + Whoosh
  - 结合向量搜索和全文搜索的优势
  - 支持结果融合和排序

### 数据存储
- **主数据库**: SQLite
  - 轻量级关系数据库，无需额外服务
  - 支持ACID事务，适合本地应用
- **向量数据库**: Faiss索引文件
  - 高效存储和检索向量嵌入
- **全文数据库**: Whoosh索引文件
  - 存储倒排索引和搜索元数据

## 2. 系统架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Electron 桌面应用                            │
├─────────────────────────────────────────────────────────────────────┤
│                     Vue 3 前端框架                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐        │
│  │ 搜索组件     │  │ 索引组件     │  │ 配置组件          │        │
│  │ - 多模态输入  │  │ - 索引管理   │  │ - AI模型配置      │        │
│  │ - 结果展示   │  │ - 索引状态   │  │ - 应用设置        │        │
│  └──────────────┘  └──────────────┘  └──────────────────┘        │
├─────────────────────────────────────────────────────────────────────┤
│                   HTTP API 通信层                              │
│                 (Axios + FastAPI)                              │
├─────────────────────────────────────────────────────────────────────┤
│                           ┌                                     │
│                         后端服务                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐        │
│  │ 搜索API      │  │ 索引API      │  │ 配置API            │        │
│  │ /api/search  │  │ /api/index   │  │ /api/config        │        │
│  └──────────────┘  └──────────────┘  └──────────────────┘        │
├─────────────────────────────────────────────────────────────────────┤
│                   核心服务层                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐        │
│  │ 搜索服务     │  │ 索引服务     │  │ AI模型服务         │        │
│  │ - 向量搜索   │  │ - 文件扫描   │  │ - 文本嵌入         │        │
│  │ - 全文搜索   │  │ - 索引构建   │  │ - 语音识别         │        │
│  │ - 混合搜索   │  │ - 索引管理   │  │ - 图像理解         │        │
│  └──────────────┘  └──────────────┘  └──────────────────┘        │
├─────────────────────────────────────────────────────────────────────┤
│                   AI模型层                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐        │
│  │ BGE-M3       │  │ FasterWhisp │  │ CN-CLIP           │        │
│  │ 文本嵌入      │  │ 语音识别     │  │ 图像理解           │        │
│  │ + Ollama      │  │ + 阿里云API │  │ + 阿里云API       │        │
│  └──────────────┘  └──────────────┘  └──────────────────┘        │
├─────────────────────────────────────────────────────────────────────┤
│                   存储引擎                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐        │
│  │ Faiss        │  │ Whoosh      │  │ SQLite            │        │
│  │ 向量索引      │  │ 全文索引     │  │ 配置/元数据        │        │
│  │ 高效检索      │  │ 模糊搜索     │  │ 搜索历史          │        │
│  └──────────────┘  └──────────────┘  └──────────────────┘        │
└─────────────────────────────────────────────────────────────────────┘
```

**架构特点**：
1. **前后端分离**: Vue3前端 + FastAPI后端，通过HTTP API通信
2. **异步处理**: FastAPI异步架构，支持高并发搜索请求
3. **AI模型集成**: 多种AI模型的统一管理和调用
4. **本地优先**: 本地数据存储和处理，保护用户隐私
5. **可扩展性**: 模块化设计，支持新AI模型和功能扩展

## 3. 数据存储设计

### SQLite 关系数据库设计

#### files 文件索引表
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PRIMARY KEY AUTOINCREMENT | 主键 |
| file_path | TEXT UNIQUE NOT NULL | 文件绝对路径 |
| file_name | TEXT NOT NULL | 文件名 |
| file_extension | TEXT NOT NULL | 文件扩展名 |
| file_type | TEXT NOT NULL | 文件类型(video/audio/document/image) |
| file_size | INTEGER NOT NULL | 文件大小(字节) |
| created_at | DATETIME NOT NULL | 文件创建时间 |
| modified_at | DATETIME NOT NULL | 文件修改时间 |
| indexed_at | DATETIME NOT NULL | 索引时间 |
| content_hash | TEXT NOT NULL | 文件内容哈希(用于变更检测) |
| faiss_index_id | INTEGER | 关联Faiss向量索引ID |
| whoosh_doc_id | TEXT | 关联Whoosh文档ID |

#### search_history 搜索历史表
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PRIMARY KEY AUTOINCREMENT | 主键 |
| search_query | TEXT NOT NULL | 搜索查询 |
| input_type | TEXT NOT NULL | 输入类型(voice/text/image) |
| search_type | TEXT NOT NULL | 搜索类型(semantic/fulltext/hybrid) |
| ai_model_used | TEXT | 使用的AI模型 |
| result_count | INTEGER NOT NULL | 结果数量 |
| response_time | REAL NOT NULL | 响应时间(秒) |
| created_at | DATETIME NOT NULL | 搜索时间 |

#### ai_models AI模型配置表
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PRIMARY KEY AUTOINCREMENT | 主键 |
| model_type | TEXT NOT NULL | 模型类型(embedding/speech/vision/llm) |
| provider | TEXT NOT NULL | 提供商类型(local/cloud) |
| model_name | TEXT NOT NULL | 模型名称 |
| config_json | TEXT NOT NULL | JSON格式配置参数 |
| is_active | BOOLEAN DEFAULT TRUE | 是否启用 |
| created_at | DATETIME NOT NULL | 创建时间 |
| updated_at | DATETIME NOT NULL | 更新时间 |

#### index_jobs 索引任务表
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PRIMARY KEY AUTOINCREMENT | 主键 |
| folder_path | TEXT NOT NULL | 索引文件夹路径 |
| job_type | TEXT NOT NULL | 任务类型(create/update/rebuild/delete) |
| status | TEXT NOT NULL | 任务状态(pending/processing/completed/failed) |
| total_files | INTEGER DEFAULT 0 | 总文件数 |
| processed_files | INTEGER DEFAULT 0 | 已处理文件数 |
| error_count | INTEGER DEFAULT 0 | 错误文件数 |
| started_at | DATETIME | 开始时间 |
| completed_at | DATETIME | 完成时间 |
| error_message | TEXT | 错误信息 |

### Faiss 向量索引设计
```python
# BGE-M3模型配置
embedding_dim = 768  # BGE-M3向量维度
nlist = 100  # IVF索引的聚类数量
m = 32  # PQ编码参数

# 索引存储目录
faiss_index/
├── document_index.faiss     # Faiss向量索引文件
├── metadata.pkl            # 向量元数据
│   {vector_id: {
│       "file_id": 1,
│       "chunk_text": "文档内容片段",
│       "chunk_index": 0,
│       "file_type": "document"
│   }}
└── index_config.json       # 索引配置信息
```

### Whoosh 全文索引设计
```python
# Whoosh Schema设计
from whoosh.fields import Schema, TEXT, ID, DATETIME, KEYWORD

search_schema = Schema(
    file_id=ID(stored=True, unique=True),
    file_path=ID(stored=True),
    file_name=TEXT(stored=True, analyzer=ChineseAnalyzer()),
    file_type=KEYWORD(stored=True),
    content=TEXT(stored=True, phrase=True, analyzer=ChineseAnalyzer()),
    title=TEXT(stored=True, analyzer=ChineseAnalyzer()),
    tags=KEYWORD(stored=True, commas=True),
    created_at=DATETIME(stored=True),
    modified_at=DATETIME(stored=True),
    indexed_at=DATETIME(stored=True)
)

# 索引存储目录
whoosh_index/
├── MAIN_0.seg             # 主索引段
├── segments_0001         # 段信息
├── _toc.json            # 索引目录
└── _per.doc             # 文档数据
```

### 混合搜索引擎实现
```python
class HybridSearchEngine:
    def __init__(self):
        self.faiss_index = FaissIndexManager()
        self.whoosh_index = WhooshIndexManager()
        self.bge_model = BGEM3Model()
        self.result_fusion = ResultFusion()

    async def search(self, query: str, search_type: str = "hybrid",
                    limit: int = 20, threshold: float = 0.7):
        """
        混合搜索引擎主入口
        """
        if search_type == "semantic":
            return await self.semantic_search(query, limit, threshold)
        elif search_type == "fulltext":
            return await self.fulltext_search(query, limit)
        else:  # hybrid
            return await self.hybrid_search(query, limit, threshold)

    async def hybrid_search(self, query: str, limit: int, threshold: float):
        # 1. 并行执行语义搜索和全文搜索
        semantic_task = self.semantic_search(query, limit * 2, threshold)
        fulltext_task = self.fulltext_search(query, limit * 2)

        semantic_results, fulltext_results = await asyncio.gather(
            semantic_task, fulltext_task
        )

        # 2. 结果融合
        final_results = await self.result_fusion.merge_and_rerank(
            semantic_results,
            fulltext_results,
            query,
            limit
        )

        return final_results
```

## 4. API接口设计

### Pydantic数据模型
```python
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

class InputType(str, Enum):
    TEXT = "text"
    VOICE = "voice"
    IMAGE = "image"

class SearchType(str, Enum):
    SEMANTIC = "semantic"
    FULLTEXT = "fulltext"
    HYBRID = "hybrid"

class FileType(str, Enum):
    VIDEO = "video"
    AUDIO = "audio"
    DOCUMENT = "document"
    IMAGE = "image"

# 搜索请求模型
class SearchRequest(BaseModel):
    query: str = Field(..., description="搜索查询词", min_length=1, max_length=500)
    input_type: InputType = Field(InputType.TEXT, description="输入类型")
    search_type: SearchType = Field(SearchType.HYBRID, description="搜索类型")
    limit: int = Field(20, ge=1, le=100, description="返回结果数量")
    threshold: float = Field(0.7, ge=0.0, le=1.0, description="相似度阈值")
    file_types: Optional[List[FileType]] = Field(None, description="文件类型过滤")

class MultimodalRequest(BaseModel):
    input_data: str = Field(..., description="Base64编码的文件数据")
    input_type: InputType = Field(..., description="输入类型voice或image")
    duration: Optional[int] = Field(30, ge=1, le=120, description="音频最长时长秒数")

class IndexCreateRequest(BaseModel):
    folder_path: str = Field(..., description="索引文件夹路径")
    file_types: List[str] = Field(
        default=["pdf", "txt", "md", "mp3", "mp4", "wav", "docx", "xlsx"],
        description="支持文件类型"
    )
    recursive: bool = Field(True, description="是否递归搜索子文件夹")

class AIModelConfigRequest(BaseModel):
    model_type: str = Field(..., regex="^(embedding|speech|vision|llm)$")
    provider: str = Field(..., regex="^(local|cloud)$")
    model_name: str = Field(..., min_length=1, max_length=100)
    config: Dict[str, Any] = Field(..., description="模型配置参数")

# 搜索响应模型
class SearchResult(BaseModel):
    file_id: int
    file_name: str
    file_path: str
    file_type: FileType
    relevance_score: float = Field(..., ge=0.0, le=1.0)
    preview_text: str = Field(..., max_length=200)
    highlight: str
    created_at: datetime
    modified_at: datetime
    file_size: int
    match_type: str  # semantic/fulltext/hybrid

class SearchResponse(BaseModel):
    success: bool = True
    data: Dict[str, Any]
    message: Optional[str] = None

class MultimodalResponse(BaseModel):
    success: bool = True
    data: Dict[str, Any]
    message: Optional[str] = None
```

### FastAPI路由实现
```python
from fastapi import FastAPI, HTTPException, BackgroundTasks, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn

app = FastAPI(
    title="小遥搜索 API",
    description="多模态AI智能搜索桌面应用后端",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS中间件，支持Electron跨域访问
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Electron渲染进程地址
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 1. 搜索服务接口
@app.post("/api/search", response_model=SearchResponse)
async def search_files(request: SearchRequest):
    """
    执行搜索请求

    - **query**: 搜索查询词1-500字符
    - **input_type**: 输入类型text/voice/image
    - **search_type**: 搜索类型semantic/fulltext/hybrid
    - **limit**: 返回结果数量1-100
    - **threshold**: 相似度阈值0.0-1.0
    - **file_types**: 文件类型过滤
    """
    start_time = time.time()

    try:
        # 1. 处理不同输入类型的预处理
        if request.input_type == InputType.VOICE:
            # 语音识别处理
            converted_text = await speech_to_text_service.transcribe(request.query)
        elif request.input_type == InputType.IMAGE:
            # 图像理解处理
            converted_text = await vision_to_text_service.analyze(request.query)
        else:
            converted_text = request.query

        # 2. 执行搜索
        search_engine = HybridSearchEngine()
        results = await search_engine.search(
            query=converted_text,
            search_type=request.search_type,
            limit=request.limit,
            threshold=request.threshold,
            file_types=request.file_types
        )

        # 3. 保存搜索历史
        search_time = time.time() - start_time
        await save_search_history(
            query=request.query,
            input_type=request.input_type,
            search_type=request.search_type,
            result_count=len(results),
            response_time=search_time
        )

        return SearchResponse(
            data={
                "results": results,
                "total": len(results),
                "search_time": round(search_time, 2),
                "query_used": converted_text,
                "input_processed": request.input_type != InputType.TEXT
            }
        )

    except Exception as e:
        logger.error(f"搜索失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"搜索失败: {str(e)}")

@app.post("/api/search/multimodal", response_model=MultimodalResponse)
async def multimodal_search(
    background_tasks: BackgroundTasks,
    input_type: InputType,
    file: UploadFile = File(...)
):
    """
    多模态文件搜索

    - **input_type**: 输入类型voice/image
    - **file**: 上传的文件数据
    """
    try:
        # 1. 验证文件大小
        if file.size > 50 * 1024 * 1024:  # 50MB限制
            raise HTTPException(status_code=400, detail="文件大小不能超过50MB")

        file_content = await file.read()
        base64_data = base64.b64encode(file_content).decode()

        # 2. 多模态处理
        if input_type == InputType.VOICE:
            # 使用FasterWhisper本地处理
            if await model_service.is_local_model_available("fasterwhisper"):
                converted_text, confidence = await speech_to_text_service.faster_whisper_transcribe(
                    base64_data
                )
            else:
                # 使用阿里云API
                converted_text, confidence = await speech_to_text_service.aliyun_transcribe(
                    base64_data
                )

        elif input_type == InputType.IMAGE:
            # 使用CN-CLIP本地处理
            if await model_service.is_local_model_available("cnclip"):
                converted_text, confidence = await vision_service.cnclip_analyze(base64_data)
            else:
                # 使用阿里云视觉API
                converted_text, confidence = await vision_service.cloud_vision_analyze(base64_data)

        # 3. 执行搜索
        search_engine = HybridSearchEngine()
        search_results = await search_engine.hybrid_search(
            query=converted_text,
            limit=20,
            threshold=0.7
        )

        return MultimodalResponse(
            data={
                "converted_text": converted_text,
                "confidence": confidence,
                "search_results": search_results,
                "file_info": {
                    "filename": file.filename,
                    "size": file.size,
                    "content_type": file.content_type
                }
            }
        )

    except Exception as e:
        logger.error(f"多模态搜索失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"多模态搜索失败: {str(e)}")

# 2. 索引管理接口
@app.post("/api/index/create")
async def create_index(request: IndexCreateRequest, background_tasks: BackgroundTasks):
    """
    创建文件索引

    - **folder_path**: 索引文件夹路径
    - **file_types**: 支持文件类型
    - **recursive**: 是否递归搜索子文件夹
    """
    try:
        # 1. 验证文件夹路径
        if not os.path.exists(request.folder_path):
            raise HTTPException(status_code=400, detail="文件夹不存在")

        if not os.path.isdir(request.folder_path):
            raise HTTPException(status_code=400, detail("路径不是文件夹"))

        # 2. 检查是否有正在运行的索引任务
        existing_job = await get_active_index_job(request.folder_path)
        if existing_job:
            return {
                "success": True,
                "data": {
                    "index_id": existing_job.id,
                    "status": existing_job.status,
                    "message": "文件夹正在索引中"
                }
            }

        # 3. 创建索引任务
        index_job = await create_index_job(
            folder_path=request.folder_path,
            job_type="create",
            file_types=request.file_types,
            recursive=request.recursive
        )

        # 4. 后台执行索引任务
        background_tasks.add_task(
            run_index_task,
            index_job.id,
            request.folder_path,
            request.file_types,
            request.recursive
        )

        return {
            "success": True,
            "data": {
                "index_id": index_job.id,
                "status": "processing",
                "message": "索引任务已创建并开始执行"
            }
        }

    except Exception as e:
        logger.error(f"创建索引失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"创建索引失败: {str(e)}")

@app.get("/api/index/status/{index_id}")
async def get_index_status(index_id: int):
    """
    获取索引状态
    """
    try:
        job = await get_index_job(index_id)
        if not job:
            raise HTTPException(status_code=404, detail="索引任务不存在")

        # 计算进度百分比
        progress = 0
        if job.total_files > 0:
            progress = int((job.processed_files / job.total_files) * 100)

        return {
            "success": True,
            "data": {
                "index_id": job.id,
                "folder_path": job.folder_path,
                "status": job.status,
                "progress": progress,
                "total_files": job.total_files,
                "processed_files": job.processed_files,
                "error_count": job.error_count,
                "started_at": job.started_at,
                "completed_at": job.completed_at,
                "error_message": job.error_message
            }
        }

    except Exception as e:
        logger.error(f"获取索引状态失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"获取索引状态失败: {str(e)}")

@app.delete("/api/index/{index_id}")
async def delete_index(index_id: int):
    """
    删除索引和相关数据
    """
    try:
        job = await get_index_job(index_id)
        if not job:
            raise HTTPException(status_code=404, detail="索引任务不存在")

        # 如果任务正在运行，停止任务
        if job.status == "processing":
            await stop_index_task(index_id)

        # 删除索引数据
        await delete_index_data(job.folder_path)
        await delete_index_job(index_id)

        return {"success": True, "message": "索引删除成功"}

    except Exception as e:
        logger.error(f"删除索引失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"删除索引失败: {str(e)}")

# 3. AI模型配置管理
@app.post("/api/config/ai-model")
async def update_ai_model_config(request: AIModelConfigRequest):
    """
    更新AI模型配置

    - **model_type**: 模型类型embedding/speech/vision/llm
    - **provider**: 提供商类型local/cloud
    - **model_name**: 模型名称
    - **config**: 模型配置参数
    """
    try:
        # 1. 验证模型配置
        if not await model_service.validate_model_config(
            request.model_type, request.provider, request.config
        ):
            raise HTTPException(status_code=400, detail="模型配置验证失败")

        # 2. 保存配置到数据库
        await save_model_config(
            model_type=request.model_type,
            provider=request.provider,
            model_name=request.model_name,
            config=request.config
        )

        # 3. 检查本地模型文件是否存在
        if request.provider == "local":
            model_path = request.config.get("model_path")
            if model_path and not os.path.exists(model_path):
                logger.warning(f"本地模型文件不存在: {model_path}")

        return {"success": True, "message": "AI模型配置更新成功"}

    except Exception as e:
        logger.error(f"更新AI模型配置失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"更新AI模型配置失败: {str(e)}")

@app.get("/api/config/ai-models")
async def get_ai_models():
    """
    获取所有AI模型配置
    """
    try:
        models = await get_all_model_configs()
        return {"success": True, "data": models}

    except Exception as e:
        logger.error(f"获取AI模型配置失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"获取AI模型配置失败: {str(e)}")

@app.post("/api/config/ai-model/{model_id}/test")
async def test_ai_model(model_id: int):
    """
    测试AI模型连通性
    """
    try:
        model_config = await get_model_config(model_id)
        if not model_config:
            raise HTTPException(status_code=404, detail="模型配置不存在")

        test_result = await model_service.test_model(model_config)

        return {
            "success": True,
            "data": {
                "model_id": model_id,
                "test_passed": test_result["success"],
                "response_time": test_result["response_time"],
                "test_message": test_result["message"]
            }
        }

    except Exception as e:
        logger.error(f"测试AI模型失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"测试AI模型失败: {str(e)}")

# 4. 应用配置管理
@app.get("/api/settings")
async def get_settings():
    """获取应用设置"""
    try:
        settings = await load_app_settings()
        return {"success": True, "data": settings}

    except Exception as e:
        logger.error(f"获取应用设置失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"获取应用设置失败: {str(e)}")

@app.post("/api/settings")
async def update_settings(settings: Dict[str, Any]):
    """更新应用设置"""
    try:
        await save_app_settings(settings)
        return {"success": True, "message": "设置更新成功"}

    except Exception as e:
        logger.error(f"更新应用设置失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"更新应用设置失败: {str(e)}")

@app.get("/api/system/health")
async def health_check():
    """
    系统健康检查
    """
    try:
        # 检查数据库连接
        db_status = await check_database_connection()

        # 检查AI模型状态
        ai_models_status = await check_ai_models_status()

        # 检查索引状态
        index_status = await check_indexes_health()

        return {
            "success": True,
            "data": {
                "status": "healthy",
                "database": db_status,
                "ai_models": ai_models_status,
                "indexes": index_status,
                "timestamp": datetime.now().isoformat()
            }
        }

    except Exception as e:
        logger.error(f"健康检查失败: {str(e)}")
        return {
            "success": False,
            "data": {
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
        }

# 启动服务
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="127.0.0.1",
        port=8000,
        log_level="info",
        reload=True
    )
```

## 5. AI模型集成方案

### 本地AI模型部署
```python
# BGE-M3文本嵌入模型
class BGEModel:
    def __init__(self, model_path="BAAI/bge-m3"):
        self.model = SentenceTransformer(model_path)
        self.embedding_dim = 768

    async def encode(self, text: str) -> np.ndarray:
        """文本向量化"""
        return self.model.encode(text, normalize_embeddings=True)

# FasterWhisper语音识别
class FasterWhisperService:
    def __init__(self, model_size="base"):
        self.model = WhisperModel(model_size, compute_type="auto")

    async def transcribe(self, audio_data: bytes) -> tuple[str, float]:
        """语音识别转录"""
        with tempfile.NamedTemporaryFile(suffix=".wav") as f:
            f.write(audio_data)
            segments, info = self.model.transcribe(f.name)

        text = " ".join([segment.text for segment in segments])
        confidence = info.avg_logprob  # 平均置信度

        return text, confidence

# CN-CLIP图像理解模型
class CNCLIPService:
    def __init__(self, model_path="OFA-Sys/chinese-clip-vit-base-patch16"):
        self.model, self.processor = load_model(model_path)

    async def analyze_image(self, image_data: bytes) -> tuple[str, float]:
        """图像理解生成文本描述"""
        # 图像预处理和模型推理
        pass
```

### 云端API服务方案
```python
# 阿里云语音识别
class AliyunSpeechService:
    def __init__(self, access_key: str, access_key_secret: str):
        self.client = NlsClient(access_key, access_key_secret)

    async def transcribe(self, audio_data: bytes) -> tuple[str, float]:
        """语音识别"""
        # 调用阿里云ASR API
        pass

# 阿里云视觉API
class CloudVisionService:
    def __init__(self, api_key: str, endpoint: str):
        self.api_key = api_key
        self.endpoint = endpoint

    async def analyze_image(self, image_data: bytes) -> tuple[str, float]:
        """图像理解"""
        # 调用视觉理解API
        pass
```

### 模型容灾机制
```python
class ModelFallbackManager:
    def __init__(self):
        self.primary_models = {}
        self.backup_models = {}

    async def get_embedding(self, text: str):
        """文本嵌入模型容灾"""
        try:
            # 优先使用BGE-M3
            if self.primary_models.get("bge_m3"):
                return await self.primary_models["bge_m3"].encode(text)
        except Exception as e:
            logger.warning(f"BGE-M3模型失败: {str(e)}")

        try:
            # 备用轻量模型
            if self.backup_models.get("lightweight"):
                return await self.backup_models["lightweight"].encode(text)
        except Exception as e:
            logger.error(f"备用模型失败: {str(e)}")

        # 最后使用TF-IDF降级方案
        return await self.tfidf_fallback(text)
```

## 6. 性能优化方案

| 优化方面 | 当前性能 | 优化目标 | 实现方案 |
|---------|---------|----------|----------|
| **AI模型启动** | BGE-M3加载需要4-8GB内存 | 低 | 1. 模型量化INT8 2. 备用轻量模型 3. 延迟加载 |
| **语音识别启动** | FasterWhisper(本地)模型加载 | 中 | 1. 预加载模型 2. 阿里云API备选 3. 缓存处理结果 |
| **跨进程通信** | Electron + Python进程间通信 | 中 | 1. WebSocket通信 2. 消息队列缓冲 3. 本地IPC管道 |
| **向量搜索性能** | Faiss索引10万+文件查询 | 高 | 1. 优化索引结构 2. 分片搜索 3. 并行处理 |
| **全文搜索性能** | Whoosh中文全文搜索 | 中 | 1. 优化jieba分词 2. 索引优化 3. 并行搜索结果合并 |
| **模型服务依赖** | transformers/PyTorch环境依赖 | 无 | 1. 容器化部署 2. 模型版本管理 3. 依赖隔离 |
| **内存使用监控** | 未做内存限制，可能出现OOM | 中 | 1. 实时监控内存使用 2. 动态加载释放 3. 内存溢出保护 |

### Python后端性能优化

**硬件环境要求**：
- PyTorch和CUDA环境
- AI模型推理GPU支持
- 足够的磁盘空间存储模型

**内存优化方案**：
- BGE-M3模型量化加载
- 语音和图像处理资源缓存
- 多模态处理内存池

**并发处理优化**：
- FastAPI并发性能优化
- 大文件索引并行处理
- 搜索结果并发处理

### Vue3 + Electron性能优化

**前端优化方案**：
- 搜索结果虚拟滚动
- 组件按需加载
- 响应式数据优化

**通信优化方案**：
- 优化进程间通信
- Python后端连接池
- 结果缓存和防抖

### 系统级性能优化方案

```python
# 内存监控
class MemoryMonitor:
    def __init__(self, threshold=8):  # 8GB阈值
        self.threshold = threshold * 1024 * 1024 * 1024
        self.check_interval = 30  # 30秒检查一次

    async def start_monitoring(self):
        while True:
            await asyncio.sleep(self.check_interval)
            await self.check_memory()

    async def check_memory(self):
        import psutil
        memory_usage = psutil.Process().memory_info().rss
        if memory_usage > self.threshold:
            logger.warning(f"内存使用超限: {memory_usage / 1024**3:.2f}GB")
            await self.cleanup_memory()

    async def cleanup_memory(self):
        # 1. 清理未使用的模型
        # 2. 释放向量索引
        # 3. 强制垃圾回收
        gc.collect()

# 并发任务管理
class AsyncTaskManager:
    def __init__(self, max_concurrent=3):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.running_tasks = {}

    async def submit_task(self, task_id: str, task_func, *args, **kwargs):
        async with self.semaphore:
            try:
                task = asyncio.create_task(task_func(*args, **kwargs))
                self.running_tasks[task_id] = task
                result = await task
                return result
            except Exception as e:
                logger.error(f"任务{task_id}失败: {str(e)}")
                raise
            finally:
                self.running_tasks.pop(task_id, None)

    async def cancel_task(self, task_id: str):
        if task_id in self.running_tasks:
            self.running_tasks[task_id].cancel()
            return True
        return False
```

## 7. 项目配置

### 开发工具配置
- **版本控制**: GitHub
- **项目管理**: GitHub Projects + Notion
- **IDE插件**: VSCode + 华为云API插件
- **本地环境**: Python虚拟环境 + Node.js包管理
- **代码质量**: ESLint + Prettier + Black + isort + Husky

### 项目目录结构
```
xiaoyaosearch/
├── frontend/                    # Electron + Vue3前端
│   ├── src/
│   │   ├── main/               # Electron主进程
│   │   │   ├── services/       # 核心服务
│   │   │   └── utils/          # 工具函数
│   │   ├── renderer/           # 渲染进程Vue3
│   │   │   ├── components/     # UI组件
│   │   │   ├── pages/         # 页面组件
│   │   │   ├── views/         # 页面视图
│   │   │   ├── stores/        # Pinia状态管理
│   │   │   ├── hooks/         # 自定义hooks
│   │   │   ├── utils/         # 工具函数
│   │   │   └── api/           # API请求封装
│   │   └── shared/            # 共享类型定义
│   ├── public/                # 静态资源
│   ├── package.json
│   └── electron-builder.json  # 应用打包配置
├── backend/                    # Python FastAPI后端
│   ├── app/
│   │   ├── api/               # API路由
│   │   │   └── v1/            # API v1版本
│   │   │       ├── search.py  # 搜索接口
│   │   │       ├── index.py   # 索引管理
│   │   │       ├── config.py  # 配置管理
│   │   │       └── system.py  # 系统接口
│   │   ├── deps.py            # 依赖注入
│   │   ├── core/              # 核心模块
│   │   │   ├── search/        # 搜索引擎
│   │   │   ├── indexing/      # 索引管理
│   │   │   ├── ai_models/     # AI模型服务
│   │   │   └── database/      # 数据库操作
│   │   ├── models/            # 数据模型
│   │   ├── schemas/           # Pydantic模型
│   │   ├── services/          # 业务服务
│   │   └── utils/             # 工具函数
│   ├── tests/                 # 测试用例
│   ├── requirements.txt       # Python依赖
│   ├── main.py               # 应用入口
├── models/                    # AI模型文件
│   ├── bge-m3/               # BGE-M3模型
│   ├── faster-whisper/       # FasterWhisper模型
│   └── cn-clip/              # CN-CLIP模型
├── data/                     # 应用数据
│   ├── database/             # SQLite数据库
│   ├── indexes/              # 搜索索引
│   └── configs/              # 配置文件
├── scripts/                  # 部署脚本
│   ├── build.sh             # 构建脚本
│   ├── start_services.sh     # 启动脚本
│   └── setup_env.sh         # 环境配置
└── docs/                     # 文档
    ├── api.md              # API文档
    ├── deployment.md       # 部署文档
    └── development.md      # 开发文档
```

### 依赖管理

#### Python后端依赖
```txt
# requirements.txt

# AI模型相关
sentence-transformers==2.2.2     # BGE-M3模型支持
faster-whisper==0.9.0            # 本地语音识别
clip-by-openai==1.0              # CLIP模型支持
transformers==4.35.0             # HuggingFace模型库
torch==2.1.0                     # PyTorch深度学习框架
torchvision==0.16.0              # 视觉模型支持
Pillow==10.1.0                   # 图像处理

# 搜索引擎
faiss-cpu==1.7.4                 # Facebook向量搜索
whoosh==2.7.4                    # Python全文搜索
jieba==0.42.1                    # 中文分词

# Web框架
fastapi==0.104.1                 # Python Web框架
uvicorn[standard]==0.24.0        # ASGI服务器
pydantic==2.5.0                  # 数据验证
pydantic-settings==2.1.0         # 配置管理

# 数据库
sqlalchemy==2.0.23               # SQL工具包
alembic==1.13.1                  # 数据库迁移

# 文件处理
PyPDF2==3.0.1                    # PDF文件处理
python-docx==0.8.11              # Word文档处理
openpyxl==3.1.2                  # Excel文件处理
mutagen==1.47.0                  # 音频元数据

# HTTP客户端
oss2==2.18.0                     # 阿里云对象存储
requests==2.31.0                 # HTTP请求库

# 系统监控
watchdog==3.0.0                  # 文件监控
tqdm==4.66.1                     # 进度条
psutil==5.9.6                    # 系统监控
python-multipart==0.0.6          # 文件上传

# 测试工具
pytest==7.4.3                   # 测试框架
pytest-asyncio==0.21.1           # 异步测试
black==23.11.0                   # 代码格式化
isort==5.12.0                    # 导入排序
mypy==1.7.1                      # 类型检查
```

#### Vue3前端依赖
```json
{
  "name": "xiaoyaosearch-desktop",
  "version": "1.0.0",
  "dependencies": {
    "vue": "^3.3.8",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "ant-design-vue": "^4.0.7",
    "axios": "^1.6.2",
    "@vueuse/core": "^10.6.1",
    "dayjs": "^1.11.10"
  },
  "devDependencies": {
    "electron": "^27.1.3",
    "electron-builder": "^24.6.4",
    "@vitejs/plugin-vue": "^4.5.0",
    "vite": "^5.0.0",
    "typescript": "^5.3.2",
    "@vue/tsconfig": "^0.4.0",
    "@types/node": "^20.9.4",
    "eslint": "^8.54.0",
    "@typescript-eslint/eslint-plugin": "^6.12.0",
    "prettier": "^3.1.0",
    "husky": "^8.0.3"
  }
}
```

### 项目环境配置脚本

#### 环境初始化脚本 (setup_env.sh)
```bash
#!/bin/bash

echo "初始化小遥搜索开发环境..."

# 1. 检查Python版本
python_version=$(python3 --version 2>&1 | awk '{print $2}')
echo "Python版本: $python_version"

# 2. 检查Node.js版本
node_version=$(node --version 2>&1)
echo "Node.js版本: $node_version"

# 3. 创建Python虚拟环境
echo "创建Python虚拟环境..."
cd backend
python3 -m venv venv
source venv/bin/activate

# 4. 安装Python依赖
echo "安装Python依赖..."
pip install --upgrade pip
pip install -r requirements.txt

# 5. 安装前端依赖
echo "安装前端依赖..."
cd ../frontend
npm install

# 6. 创建数据目录
echo "创建数据目录结构..."
mkdir -p ../data/database
mkdir -p ../data/indexes/faiss
mkdir -p ../data/indexes/whoosh
mkdir -p ../data/configs

echo "环境初始化完成"
echo ""
echo "启动开发服务:"
echo "1. 启动后端: cd backend && source venv/bin/activate && python main.py"
echo "2. 启动前端: cd frontend && npm run electron:dev"
```

#### 开发服务启动脚本 (start_dev.sh)
```bash
#!/bin/bash

echo "启动小遥搜索开发服务..."

# 启动后端服务
echo "启动FastAPI后端服务..."
cd backend
source venv/bin/activate
python main.py &
BACKEND_PID=$!
echo "后端服务PID: $BACKEND_PID"

# 等待后端启动
sleep 3

# 启动前端应用
echo "启动Electron前端应用..."
cd ../frontend
npm run electron:dev &
FRONTEND_PID=$!
echo "前端应用PID: $FRONTEND_PID"

# 显示进程信息
echo ""
echo "服务启动完成"
echo "按 Ctrl+C 停止服务"

# 监听退出信号
trap 'echo "正在停止服务..."; kill $BACKEND_PID $FRONTEND_PID; exit' INT

wait
```

### 代码质量控制

#### 前端代码规范配置
```javascript
// .eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'eslint:recommended',
    '@vue/typescript/recommended',
    '@vue/prettier',
    '@vue/prettier/@typescript-eslint'
  ],
  parserOptions: {
    ecmaVersion: 2021
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
  }
}
```

#### Git提交钩子配置 (.husky/pre-commit)
```bash
#!/bin/sh
# .husky/pre-commit

# 运行前端代码检查
echo "运行前端代码检查..."
cd frontend
npm run lint

# 运行后端代码检查
echo "运行后端代码检查..."
cd ../backend
source venv/bin/activate
black --check .
isort --check-only .
mypy app/

# 运行测试
echo "运行测试..."
python -m pytest tests/ -v
```

---

**开发周期**: 8-10周
**预计上线时间**: 2025年2月底

**开发阶段规划**:
1. **第1-2周**: 基础架构和AI模型集成
2. **第3-4周**: 搜索引擎和API接口开发
3. **第5-6周**: 前端界面和交互开发
4. **第7-8周**: 功能优化和性能调优
5. **第9-10周**: 测试、打包和发布准备